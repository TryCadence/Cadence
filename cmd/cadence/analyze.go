package main

import (
	"fmt"
	"os"
	"strings"

	gogit "github.com/go-git/go-git/v5"
	"github.com/spf13/cobra"

	"github.com/codemeapixel/cadence/internal/analyzer"
	"github.com/codemeapixel/cadence/internal/config"
	"github.com/codemeapixel/cadence/internal/detector"
	"github.com/codemeapixel/cadence/internal/git"
	"github.com/codemeapixel/cadence/internal/metrics"
	"github.com/codemeapixel/cadence/internal/reporter"
)

var (
	analyzeOutput              string
	analyzeSuspiciousAdditions int64
	analyzeSuspiciousDeletions int64
	analyzeMaxAdditionsMin     float64
	analyzeMaxDeletionsMin     float64
	analyzeMinTimeDelta        int64
	analyzeBranch              string
	analyzeExcludeFiles        []string
)

var analyzeCmd = &cobra.Command{
	Use:   "analyze <repository>",
	Short: "Analyze repository for suspicious commits",
	Long: `Analyze a git repository to detect commits that may have been generated by AI.

The repository argument should be a local directory path to a git repository

Requires threshold configuration via flags or config file`,
	Args: cobra.ExactArgs(1),
	RunE: runAnalyze,
}

func init() {
	analyzeCmd.Flags().StringVarP(&analyzeOutput, "output", "o", "", "output file path (required, format detected from extension: .txt or .json)")
	_ = analyzeCmd.MarkFlagRequired("output")
	analyzeCmd.Flags().Int64Var(&analyzeSuspiciousAdditions, "suspicious-additions", 0, "flag commits with more than this many additions (0 to disable)")
	analyzeCmd.Flags().Int64Var(&analyzeSuspiciousDeletions, "suspicious-deletions", 0, "flag commits with more than this many deletions (0 to disable)")
	analyzeCmd.Flags().Float64Var(&analyzeMaxAdditionsMin, "max-additions-pm", 0, "max additions per minute (0 to disable)")
	analyzeCmd.Flags().Float64Var(&analyzeMaxDeletionsMin, "max-deletions-pm", 0, "max deletions per minute (0 to disable)")
	analyzeCmd.Flags().Int64Var(&analyzeMinTimeDelta, "min-time-delta", 0, "min seconds between commits (0 to disable)")
	analyzeCmd.Flags().StringVar(&analyzeBranch, "branch", "", "branch to analyze")
	analyzeCmd.Flags().StringSliceVar(&analyzeExcludeFiles, "exclude-files", []string{}, "file patterns to exclude (e.g., *.log,*.tmp)")
}

func runAnalyze(cmd *cobra.Command, args []string) error {
	repoPath := args[0]
	var cleanup func() error

	outputFormat, err := detectFormatFromExtension(analyzeOutput)
	if err != nil {
		return err
	}

	// Handle remote repositories (GitHub URLs)
	if isRemoteRepo(repoPath) {
		// Parse GitHub web URLs to git clone URLs
		gitURL, extractedBranch, err := parseGitHubURL(repoPath)
		if err != nil {
			return fmt.Errorf("failed to parse repository URL: %w", err)
		}

		// Use extracted branch if no branch flag was provided
		if analyzeBranch == "" && extractedBranch != "" {
			analyzeBranch = extractedBranch
		}

		fmt.Println("Cloning repository...")
		repoPath, cleanup, err = cloneRemoteRepo(gitURL)
		if err != nil {
			return fmt.Errorf("failed to clone repository: %w", err)
		}
		defer func() {
			if cleanup != nil {
				_ = cleanup()
			}
		}()
	}

	// Auto-detect cadence.yml in current directory if no config specified
	cfgPath := configFile
	if cfgPath == "" {
		if _, err := os.Stat("cadence.yml"); err == nil {
			cfgPath = "cadence.yml"
		}
	}

	cfg, err := config.Load(cfgPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if cmd.Flags().Changed("suspicious-additions") {
		cfg.Thresholds.SuspiciousAdditions = analyzeSuspiciousAdditions
	}
	if cmd.Flags().Changed("suspicious-deletions") {
		cfg.Thresholds.SuspiciousDeletions = analyzeSuspiciousDeletions
	}
	if cmd.Flags().Changed("max-additions-pm") {
		cfg.Thresholds.MaxAdditionsPerMin = analyzeMaxAdditionsMin
	}
	if cmd.Flags().Changed("max-deletions-pm") {
		cfg.Thresholds.MaxDeletionsPerMin = analyzeMaxDeletionsMin
	}
	if cmd.Flags().Changed("min-time-delta") {
		cfg.Thresholds.MinTimeDeltaSeconds = analyzeMinTimeDelta
	}
	if cmd.Flags().Changed("exclude-files") {
		cfg.ExcludeFiles = analyzeExcludeFiles
	}

	if cfg.Thresholds.IsZero() {
		return fmt.Errorf("no thresholds configured - please set thresholds via config file or flags")
	}

	repoOpts := &git.RepositoryOptions{
		ExcludeFiles: cfg.ExcludeFiles,
	}

	repo, err := git.OpenRepository(repoPath, repoOpts)
	if err != nil {
		return fmt.Errorf("failed to open repository: %w", err)
	}
	defer func() { _ = repo.Close() }()

	a := analyzer.New(repo)
	opts := &git.CommitOptions{
		Branch: analyzeBranch,
	}

	fmt.Fprintln(os.Stderr, "Analyzing repository...")
	result, err := a.AnalyzeRepository(opts)
	if err != nil {
		return fmt.Errorf("analysis failed: %w", err)
	}

	fmt.Fprintln(os.Stderr, "Calculating statistics...")
	stats := metrics.CalculateStats(result.Commits, result.CommitPairs)

	fmt.Fprintln(os.Stderr, "Detecting suspicious commits...")
	det, err := detector.New(&cfg.Thresholds)
	if err != nil {
		return fmt.Errorf("failed to create detector: %w", err)
	}

	suspicious := det.DetectSuspicious(result.CommitPairs, stats)

	rep, err := reporter.NewReporter(outputFormat)
	if err != nil {
		return fmt.Errorf("failed to create reporter: %w", err)
	}

	reportData := &reporter.ReportData{
		Suspicious: suspicious,
		Stats:      stats,
		Thresholds: &cfg.Thresholds,
	}

	reportStr, err := rep.Generate(reportData)
	if err != nil {
		return fmt.Errorf("failed to generate report: %w", err)
	}

	if err := os.WriteFile(analyzeOutput, []byte(reportStr), 0o600); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}
	fmt.Fprintf(os.Stderr, "Report written to %s\n", analyzeOutput)

	return nil
}

func isRemoteRepo(path string) bool {
	return len(path) > 7 && (path[:7] == "http://" || (len(path) > 8 && path[:8] == "https://"))
}

func parseGitHubURL(url string) (string, string, error) {
	// Handle GitHub web URLs like https://github.com/owner/repo/blob/branch/path
	// Convert to git clone URL: https://github.com/owner/repo.git
	// Also extract branch if present

	if !strings.Contains(url, "github.com") {
		return url, "", nil
	}

	parts := strings.Split(url, "/")
	if len(parts) < 5 {
		return url, "", nil
	}

	// Extract owner and repo
	owner := parts[3]
	repo := parts[4]
	branch := ""

	// If it's a blob/tree URL, extract the branch
	if len(parts) > 5 && (parts[5] == "blob" || parts[5] == "tree") {
		if len(parts) > 6 {
			branch = parts[6]
		}
	}

	// Construct git clone URL
	gitURL := fmt.Sprintf("https://github.com/%s/%s.git", owner, repo)
	return gitURL, branch, nil
}
func cloneRemoteRepo(repoURL string) (string, func() error, error) {
	tempDir, err := os.MkdirTemp("", "cadence-*")
	if err != nil {
		return "", nil, fmt.Errorf("failed to create temp directory: %w", err)
	}

	// Use go-git to clone the repository
	cloneOpts := &gogit.CloneOptions{
		URL: repoURL,
	}

	_, err = gogit.PlainClone(tempDir, false, cloneOpts)
	if err != nil {
		os.RemoveAll(tempDir)
		return "", nil, fmt.Errorf("failed to clone repository: %w", err)
	}

	cleanup := func() error {
		return os.RemoveAll(tempDir)
	}

	return tempDir, cleanup, nil
}
