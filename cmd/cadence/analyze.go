package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	gogit "github.com/go-git/go-git/v5"
	"github.com/spf13/cobra"

	"github.com/TryCadence/Cadence/internal/analysis"
	"github.com/TryCadence/Cadence/internal/analysis/detectors"
	"github.com/TryCadence/Cadence/internal/analysis/sources"
	"github.com/TryCadence/Cadence/internal/config"
	"github.com/TryCadence/Cadence/internal/reporter"
)

var (
	analyzeOutput              string
	analyzeSuspiciousAdditions int64
	analyzeSuspiciousDeletions int64
	analyzeMaxAdditionsMin     float64
	analyzeMaxDeletionsMin     float64
	analyzeMinTimeDelta        int64
	analyzeBranch              string
	analyzeExcludeFiles        []string
)

var analyzeCmd = &cobra.Command{
	Use:   "analyze <repository>",
	Short: "Analyze repository for suspicious commits",
	Long: `Analyze a git repository to detect commits that may have been generated by AI.

The repository argument should be a local directory path to a git repository

Requires threshold configuration via flags or config file`,
	Args: cobra.ExactArgs(1),
	RunE: runAnalyze,
}

func init() {
	analyzeCmd.Flags().StringVarP(&analyzeOutput, "output", "o", "", "output file path (required, format detected from extension: .txt or .json)")
	_ = analyzeCmd.MarkFlagRequired("output")
	analyzeCmd.Flags().Int64Var(&analyzeSuspiciousAdditions, "suspicious-additions", 0, "flag commits with more than this many additions (0 to disable)")
	analyzeCmd.Flags().Int64Var(&analyzeSuspiciousDeletions, "suspicious-deletions", 0, "flag commits with more than this many deletions (0 to disable)")
	analyzeCmd.Flags().Float64Var(&analyzeMaxAdditionsMin, "max-additions-pm", 0, "max additions per minute (0 to disable)")
	analyzeCmd.Flags().Float64Var(&analyzeMaxDeletionsMin, "max-deletions-pm", 0, "max deletions per minute (0 to disable)")
	analyzeCmd.Flags().Int64Var(&analyzeMinTimeDelta, "min-time-delta", 0, "min seconds between commits (0 to disable)")
	analyzeCmd.Flags().StringVar(&analyzeBranch, "branch", "", "branch to analyze")
	analyzeCmd.Flags().StringSliceVar(&analyzeExcludeFiles, "exclude-files", []string{}, "file patterns to exclude (e.g., *.log,*.tmp)")
}

func runAnalyze(cmd *cobra.Command, args []string) error {
	repoPath := args[0]
	var cleanup func() error

	outputFormat, err := detectFormatFromExtension(analyzeOutput)
	if err != nil {
		return err
	}

	if isRemoteRepo(repoPath) {
		gitURL, extractedBranch := parseGitHubURL(repoPath)

		if analyzeBranch == "" && extractedBranch != "" {
			analyzeBranch = extractedBranch
		}

		fmt.Fprintln(os.Stderr, "Cloning repository...")
		repoPath, cleanup, err = cloneRemoteRepo(gitURL)
		if err != nil {
			return fmt.Errorf("failed to clone repository: %w", err)
		}
		defer func() {
			if cleanup != nil {
				_ = cleanup()
			}
		}()
	}

	cfgPath := configFile
	if cfgPath == "" {
		if _, err := os.Stat("cadence.yml"); err == nil {
			cfgPath = "cadence.yml"
		}
	}

	cfg, err := config.Load(cfgPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if cmd.Flags().Changed("suspicious-additions") {
		cfg.Thresholds.SuspiciousAdditions = analyzeSuspiciousAdditions
	}
	if cmd.Flags().Changed("suspicious-deletions") {
		cfg.Thresholds.SuspiciousDeletions = analyzeSuspiciousDeletions
	}
	if cmd.Flags().Changed("max-additions-pm") {
		cfg.Thresholds.MaxAdditionsPerMin = analyzeMaxAdditionsMin
	}
	if cmd.Flags().Changed("max-deletions-pm") {
		cfg.Thresholds.MaxDeletionsPerMin = analyzeMaxDeletionsMin
	}
	if cmd.Flags().Changed("min-time-delta") {
		cfg.Thresholds.MinTimeDeltaSeconds = analyzeMinTimeDelta
	}
	if cmd.Flags().Changed("exclude-files") {
		cfg.ExcludeFiles = analyzeExcludeFiles
	}

	if cfg.Thresholds.IsZero() {
		return fmt.Errorf("no thresholds configured - please set thresholds via config file or flags")
	}

	source := sources.NewGitRepositorySource(repoPath, analyzeBranch)
	gitDetector := detectors.NewGitDetectorWithConfig(&cfg.Thresholds, &cfg.Strategies)
	runner := analysis.NewDefaultDetectionRunner()

	fmt.Fprintln(os.Stderr, "Analyzing repository...")
	report, err := runner.Run(context.Background(), source, gitDetector)
	if err != nil {
		return fmt.Errorf("analysis failed: %w", err)
	}

	if cfg.AI.Enabled && report.DetectionCount > 0 {
		fmt.Fprintf(os.Stderr, "Performing AI analysis on %d suspicious commits...\n", report.DetectionCount)
		if err := performAIAnalysisUnified(report, &cfg.AI); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: AI analysis failed: %v\n", err)
		}
	}

	formatter, err := reporter.NewAnalysisFormatter(outputFormat)
	if err != nil {
		return fmt.Errorf("failed to create formatter: %w", err)
	}

	reportStr, err := formatter.FormatAnalysis(report)
	if err != nil {
		return fmt.Errorf("failed to format report: %w", err)
	}

	reportsDir := "reports"
	if err := os.MkdirAll(reportsDir, 0o750); err != nil {
		return fmt.Errorf("failed to create reports directory: %w", err)
	}

	outputPath := filepath.Join(reportsDir, analyzeOutput)
	if err := os.WriteFile(outputPath, []byte(reportStr), 0o600); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}
	fmt.Fprintf(os.Stderr, "Report written to %s\n", outputPath)

	return nil
}

func isRemoteRepo(path string) bool {
	return len(path) > 7 && (path[:7] == "http://" || (len(path) > 8 && path[:8] == "https://"))
}

func parseGitHubURL(url string) (gitURL, branch string) {
	if !strings.Contains(url, "github.com") {
		return url, ""
	}

	parts := strings.Split(url, "/")
	if len(parts) < 5 {
		return url, ""
	}

	owner := parts[3]
	repo := parts[4]
	branch = ""

	if len(parts) > 5 && (parts[5] == "blob" || parts[5] == "tree") {
		if len(parts) > 6 {
			branch = parts[6]
		}
	}

	gitURL = fmt.Sprintf("https://github.com/%s/%s.git", owner, repo)
	return
}
func cloneRemoteRepo(repoURL string) (tempDir string, cleanup func() error, err error) {
	tempDir, err = os.MkdirTemp("", "cadence-*")
	if err != nil {
		return "", nil, fmt.Errorf("failed to create temp directory: %w", err)
	}

	cloneOpts := &gogit.CloneOptions{
		URL: repoURL,
	}

	_, err = gogit.PlainClone(tempDir, false, cloneOpts)
	if err != nil {
		_ = os.RemoveAll(tempDir)
		return "", nil, fmt.Errorf("failed to clone repository: %w", err)
	}

	cleanup = func() error {
		return os.RemoveAll(tempDir)
	}

	return tempDir, cleanup, nil
}
