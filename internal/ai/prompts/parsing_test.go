package prompts

import (
	"strings"
	"testing"
)

func TestParseAnalysisResult(t *testing.T) {
	tests := []struct {
		name              string
		responseText      string
		expectedAssess    string
		checkConfidence   bool
		expectedReasoning bool
	}{
		{
			name: "valid JSON response",
			responseText: `{
				"assessment": "likely AI-generated",
				"confidence": 0.85,
				"reasoning": "Code is too perfect",
				"indicators": ["generic", "perfect_formatting"]
			}`,
			expectedAssess:    "likely AI-generated",
			checkConfidence:   true,
			expectedReasoning: true,
		},
		{
			name:              "text without JSON",
			responseText:      "This code looks like it was generated by AI",
			expectedAssess:    "unlikely AI-generated",
			checkConfidence:   true,
			expectedReasoning: true,
		},
		{
			name:              "empty response",
			responseText:      "",
			expectedAssess:    "unlikely AI-generated",
			checkConfidence:   false,
			expectedReasoning: false,
		},
		{
			name:              "response with possibly",
			responseText:      "The code is possibly AI-generated based on patterns",
			expectedAssess:    "possibly AI-generated",
			checkConfidence:   true,
			expectedReasoning: true,
		},
		{
			name: "JSON with partial fields",
			responseText: `{
				"assessment": "possibly AI-generated",
				"confidence": 0.5
			}`,
			expectedAssess:    "possibly AI-generated",
			checkConfidence:   true,
			expectedReasoning: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseAnalysisResult(tt.responseText)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if result == nil {
				t.Errorf("expected result but got nil")
				return
			}
			if result.Assessment != tt.expectedAssess {
				t.Errorf("expected assessment %q, got %q", tt.expectedAssess, result.Assessment)
			}
			if tt.checkConfidence {
				if result.Confidence < 0 || result.Confidence > 1 {
					t.Errorf("confidence out of range: %v", result.Confidence)
				}
			}
			if tt.expectedReasoning && result.Reasoning == "" && !strings.Contains(tt.responseText, "reasoning") {
				if tt.responseText != "" {
					t.Errorf("expected reasoning but got empty string")
				}
			}
		})
	}
}

func TestGetAssessmentFromText(t *testing.T) {
	tests := []struct {
		text               string
		expectedAssess     string
		expectedConfidence float64
	}{
		{"this code is likely AI-generated", "likely AI-generated", 0.8},
		{"this code is possibly AI-generated", "possibly AI-generated", 0.5},
		{"this code was probably written by a human", "unlikely AI-generated", 0.2},
		{"", "unlikely AI-generated", 0.2},
		{"LIKELY AI", "unlikely AI-generated", 0.2},
	}

	for _, tt := range tests {
		t.Run(tt.text, func(t *testing.T) {
			assess, conf := GetAssessmentFromText(tt.text)
			if assess != tt.expectedAssess {
				t.Errorf("expected assessment %q, got %q", tt.expectedAssess, assess)
			}
			if conf != tt.expectedConfidence {
				t.Errorf("expected confidence %.1f, got %.1f", tt.expectedConfidence, conf)
			}
		})
	}
}

func TestParseConfidence(t *testing.T) {
	tests := []struct {
		input    string
		expected float64
		name     string
	}{
		{name: "string 1", input: "1", expected: 1.0},
		{name: "string 1.0", input: "1.0", expected: 1.0},
		{name: "string 0", input: "0", expected: 0.0},
		{name: "string 0.0", input: "0.0", expected: 0.0},
		{name: "string starting with 0", input: "0.5", expected: 0.5},
		{name: "empty string", input: "", expected: 0.5},
		{name: "other string", input: "unknown", expected: 0.5},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := ParseConfidence(tt.input)
			if result != tt.expected {
				t.Errorf("expected %.1f, got %.1f", tt.expected, result)
			}
		})
	}
}

func TestIntMin(t *testing.T) {
	tests := []struct {
		a, b, expected int
		name           string
	}{
		{name: "a < b", a: 5, b: 10, expected: 5},
		{name: "b < a", a: 10, b: 5, expected: 5},
		{name: "a == b", a: 5, b: 5, expected: 5},
		{name: "negative a", a: -5, b: 10, expected: -5},
		{name: "both negative", a: -10, b: -5, expected: -10},
		{name: "zero values", a: 0, b: 0, expected: 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := intMin(tt.a, tt.b)
			if result != tt.expected {
				t.Errorf("expected %d, got %d", tt.expected, result)
			}
		})
	}
}

func TestAnalysisResultStruct(t *testing.T) {
	result := &AnalysisResult{
		Assessment: "likely AI-generated",
		Confidence: 0.85,
		Reasoning:  "Code patterns suggest AI generation",
		Indicators: []string{"generic_code", "perfect_formatting"},
	}
	if result.Assessment != "likely AI-generated" {
		t.Errorf("expected 'likely AI-generated', got %q", result.Assessment)
	}
	if result.Confidence != 0.85 {
		t.Errorf("expected 0.85, got %v", result.Confidence)
	}
	if len(result.Indicators) != 2 {
		t.Errorf("expected 2 indicators, got %d", len(result.Indicators))
	}
}
